// Book Load Lambda - POST /loads/{loadId}/book
// Books a load and generates rate confirmation document

import { marshall } from '@aws-sdk/util-dynamodb';
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import {
    badRequestError,
    Booking,
    BookLoadRequest,
    BookLoadResponse,
    conflictError,
    Document,
    generateId,
    generateRequestId,
    getBookingsTableName,
    getCurrentTimestamp,
    getDocumentsBucketName,
    getDocumentsTableName,
    getItem,
    getLoadsTableName,
    internalServerError,
    Load,
    logError,
    logInfo,
    notFoundError,
    parseBody,
    successResponse,
    transactWrite,
    uploadToS3,
} from './shared';

/**
 * Generate rate confirmation document content
 */
function generateRateConfirmation(load: Load, booking: Booking): string {
  const timestamp = new Date().toLocaleString('en-US', {
    timeZone: 'America/Chicago',
    dateStyle: 'full',
    timeStyle: 'long',
  });

  return `
RATE CONFIRMATION

Confirmation Number: ${booking.bookingId}
Date: ${timestamp}

LOAD DETAILS
Load ID: ${load.loadId}
Equipment: ${load.equipment}
Weight: ${load.weightLbs} lbs
Distance: ${load.distanceMiles} miles

ORIGIN
${load.origin.address}
${load.origin.city}, ${load.origin.state}

DESTINATION
${load.destination.address}
${load.destination.city}, ${load.destination.state}

PICKUP WINDOW
${load.pickupWindow}

DELIVERY DEADLINE
${load.deliveryDeadline}

RATE INFORMATION
Rate per Mile: $${booking.finalRate.toFixed(2)}
Total Amount: $${(booking.finalRate * load.distanceMiles).toFixed(2)}

BROKER INFORMATION
Company: ${load.broker.name}
Contact: ${load.broker.contact}
Email: ${load.broker.email}
Phone: ${load.broker.phone}
Payment Terms: ${load.broker.paymentTerms}

DRIVER INFORMATION
Driver ID: ${booking.driverId}

This rate confirmation serves as a binding agreement between the carrier and broker
for the transportation services described above.

Generated by Feightly.ai
`.trim();
}

/**
 * Lambda handler for load booking
 */
export async function handler(
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> {
  const requestId = generateRequestId();

  try {
    // Extract loadId from path parameters
    const loadId = event.pathParameters?.loadId;

    if (!loadId) {
      return badRequestError('Missing loadId parameter', undefined, requestId);
    }

    // Parse request body
    const body = parseBody<BookLoadRequest>(event.body);

    if (!body) {
      return badRequestError('Missing request body', undefined, requestId);
    }

    // Validate required fields
    if (!body.driverId) {
      return badRequestError('Missing required field: driverId', undefined, requestId);
    }

    logInfo('Processing book load request', {
      operation: 'bookLoad',
      requestId,
      loadId,
      driverId: body.driverId,
    });

    // Get the load
    const load = await getItem<Load>(getLoadsTableName(), { loadId });

    if (!load) {
      return notFoundError('Load', loadId, requestId);
    }

    // Check if load is available
    if (load.status !== 'available') {
      logInfo('Load is not available', {
        operation: 'bookLoad',
        requestId,
        loadId,
        currentStatus: load.status,
      });
      return conflictError('Load is no longer available', requestId);
    }

    // Generate IDs
    const bookingId = generateId('booking');
    const docId = generateId('doc');
    const timestamp = getCurrentTimestamp();

    // Determine final rate (use bookNowRate if available, otherwise postedRate)
    const finalRate = load.bookNowRate || load.postedRate;

    // Create booking record
    const booking: Booking = {
      bookingId,
      loadId,
      driverId: body.driverId,
      finalRate,
      status: 'confirmed',
      bookedAt: timestamp,
      rateConDocId: docId,
    };

    // Generate rate confirmation document
    const rateConfirmation = generateRateConfirmation(load, booking);
    const s3Key = `rate-confirmations/${bookingId}.txt`;

    // Upload document to S3
    try {
      await uploadToS3(
        getDocumentsBucketName(),
        s3Key,
        rateConfirmation,
        'text/plain'
      );
    } catch (error) {
      logError(error, {
        operation: 'bookLoad',
        requestId,
        step: 's3Upload',
      });
      return internalServerError('Failed to generate rate confirmation document', requestId);
    }

    // Create document record
    const document: Document = {
      docId,
      loadId,
      driverId: body.driverId,
      docType: 'rate_confirmation',
      s3Key,
      createdAt: timestamp,
    };

    // Execute DynamoDB transaction
    try {
      await transactWrite([
        // Update load status to "booked"
        {
          Update: {
            TableName: getLoadsTableName(),
            Key: marshall({ loadId }),
            UpdateExpression: 'SET #status = :booked',
            ConditionExpression: '#status = :available',
            ExpressionAttributeNames: {
              '#status': 'status',
            },
            ExpressionAttributeValues: marshall({
              ':available': 'available',
              ':booked': 'booked',
            }),
          },
        },
        // Create booking record
        {
          Put: {
            TableName: getBookingsTableName(),
            Item: marshall(booking, { removeUndefinedValues: true }),
          },
        },
        // Create document record
        {
          Put: {
            TableName: getDocumentsTableName(),
            Item: marshall(document, { removeUndefinedValues: true }),
          },
        },
      ]);
    } catch (error) {
      logError(error, {
        operation: 'bookLoad',
        requestId,
        step: 'transaction',
        loadId,
      });

      // Check if it's a conditional check failure
      if ((error as any).isConditionalCheckFailure) {
        return conflictError('Load is no longer available', requestId);
      }

      return internalServerError('Failed to book load', requestId);
    }

    // Build response
    const response: BookLoadResponse = {
      bookingId,
      loadId,
      finalRate,
      rateConDocId: docId,
      status: 'confirmed',
    };

    logInfo('Load booked successfully', {
      operation: 'bookLoad',
      requestId,
      bookingId,
      loadId,
      finalRate,
    });

    return successResponse(response, 200, requestId);
  } catch (error) {
    logError(error, {
      operation: 'bookLoad',
      requestId,
      loadId: event.pathParameters?.loadId,
    });
    return internalServerError('Failed to book load', requestId);
  }
}
